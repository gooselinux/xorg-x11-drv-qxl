From 39b478c19caa61305f817e7da9fd6f239dc73621 Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Thu, 23 Sep 2010 08:16:39 +0200
Subject: [PATCH xf86-video-qxl master 4/6] Change default virtual size to match the highest available resolution

With the old default virtual size of 1024x768, using higher resolutions
is not possible without an xorg.conf. Since the default now a days is
to not have an xorg.conf, this is sort of unfortunate.

This patch makes these higher resolutions available, while keeping the
default resolution used when none is specified through xorg.conf at
1024x786, so that the spice client window won't be way too large for
smaller screens by default.

This change does come at the prize of using more memory, but that
seems like a reasonable price to pay to give us parity wrt supported
resolutions with the windows driver. Also this is a must have to allow
the to be written Linux agent to change the guest resolution to match
the client machines one when running in auto fullscreen mode.

In the long run we should add support for resizing the fb on the fly to
match the resolution.

This patch also adjusts a few (fake) clock limits to make all the
modes reported by the qxl device when compiled with a 16MB framebuffer
work.
---
 src/qxl_driver.c |   37 ++++++++++++++++++++++++++-----------
 1 files changed, 26 insertions(+), 11 deletions(-)

diff --git a/src/qxl_driver.c b/src/qxl_driver.c
index 2e90f1e..cdf4843 100644
--- a/src/qxl_driver.c
+++ b/src/qxl_driver.c
@@ -1291,6 +1291,8 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flags)
     qxl_screen_t *qxl = NULL;
     ClockRangePtr clockRanges = NULL;
     int *linePitches = NULL;
+    DisplayModePtr mode;
+    unsigned int max_x = 0, max_y = 0;
 
     CHECK_POINT();
     
@@ -1329,7 +1331,7 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flags)
     clockRanges = xnfcalloc(sizeof(ClockRange), 1);
     clockRanges->next = NULL;
     clockRanges->minClock = 10000;
-    clockRanges->maxClock = 175000;
+    clockRanges->maxClock = 400000;
     clockRanges->clockIndex = -1;
     clockRanges->interlaceAllowed = clockRanges->doubleScanAllowed = 0;
     clockRanges->ClockMulFactor = clockRanges->ClockDivFactor = 1;
@@ -1337,30 +1339,35 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flags)
 
     /* override QXL monitor stuff */
     if (pScrn->monitor->nHsync <= 0) {
-	pScrn->monitor->hsync[0].lo = 29.0;
-	pScrn->monitor->hsync[0].hi = 80.0;
+	pScrn->monitor->hsync[0].lo =  29.0;
+	pScrn->monitor->hsync[0].hi = 160.0;
 	pScrn->monitor->nHsync = 1;
     }
     if (pScrn->monitor->nVrefresh <= 0) {
 	pScrn->monitor->vrefresh[0].lo = 50;
-	pScrn->monitor->vrefresh[0].hi = 70;
+	pScrn->monitor->vrefresh[0].hi = 75;
 	pScrn->monitor->nVrefresh = 1;
     }
 
-    if (pScrn->display->virtualX == 0 && pScrn->display->virtualY == 0) {
-    	pScrn->display->virtualX = 1024;
-    	pScrn->display->virtualY = 768;
-    }
-
     /* Add any modes not in xorg's default mode list */
     for (i = 0; i < qxl->num_modes; i++)
-        if (qxl->modes[i].orientation == 0)
+        if (qxl->modes[i].orientation == 0) {
             qxl_add_mode(pScrn, qxl->modes[i].x_res, qxl->modes[i].y_res,
                          M_T_DRIVER);
+            if (qxl->modes[i].x_res > max_x)
+                max_x = qxl->modes[i].x_res;
+            if (qxl->modes[i].y_res > max_y)
+                max_y = qxl->modes[i].y_res;
+        }
+
+    if (pScrn->display->virtualX == 0 && pScrn->display->virtualY == 0) {
+    	pScrn->display->virtualX = max_x;
+    	pScrn->display->virtualY = max_y;
+    }
 
     if (0 >= xf86ValidateModes(pScrn, pScrn->monitor->Modes,
 			       pScrn->display->modes, clockRanges, linePitches,
-			       128, 2048, 128 * 4, 128, 2048,
+			       128, max_x, 128 * 4, 128, max_y,
 			       pScrn->display->virtualX,
 			       pScrn->display->virtualY,
 			       128 * 1024 * 1024, LOOKUP_BEST_REFRESH))
@@ -1370,6 +1377,14 @@ qxl_pre_init(ScrnInfoPtr pScrn, int flags)
     
     xf86PruneDriverModes(pScrn);
     pScrn->currentMode = pScrn->modes;
+    /* If no modes are specified in xorg.conf, default to 1024x768 */
+    if (pScrn->display->modes == NULL || pScrn->display->modes[0] == NULL)
+        for (mode = pScrn->modes; mode; mode = mode->next)
+            if (mode->HDisplay == 1024 && mode->VDisplay == 768) {
+                pScrn->currentMode = mode;
+                break;
+            }
+
     xf86PrintModes(pScrn);
     xf86SetDpi(pScrn, 0, 0);
 
-- 
1.7.1

